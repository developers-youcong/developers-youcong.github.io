---
title: 阿里云服务器25端口禁用之如何使用Java发邮件(解决25端口禁用问题)
date: 2019-09-07 20:55:06
tags: "Java"
---



通常我们在本地使用Java发送邮件，通常是没有问题的，但是部署到服务器的话，就可能遇到问题。当然了，这与运营商也有关系。比如我之前在咖啡主机上购买虚拟机，然后将个人网站部署上去，通常是没有问题的，没有那么多限制。



但是在阿里云上限制就比较多，比如如果端口的入口方向不开的话，可能导致你在服务器上安装的某款软件，例如常用的Tomcat，会无法使用。

一来端口没有开放，二来白名单设置问题。



今天说说阿里云服务器25端口禁用之如何解决它并成功发送邮件，首先贴完整代码，如下所示:

<!--more-->

```

package com.blog.springboot.utils;



import java.util.Properties;

import javax.mail.Authenticator;

import javax.mail.Message;

import javax.mail.MessagingException;

import javax.mail.PasswordAuthentication;

import javax.mail.Session;

import javax.mail.Transport;

import javax.mail.internet.AddressException;

import javax.mail.internet.InternetAddress;

import javax.mail.internet.MimeMessage;

import javax.mail.internet.MimeMessage.RecipientType;



public class MailUtils {





	

	public static void sendMail(String email, String emailMsg)

			throws AddressException, MessagingException {

		// 1.创建一个程序与邮件服务器会话对象 Session



		Properties props = new Properties();

		props.setProperty("mail.transport.protocol", "SMTP");

		props.setProperty("mail.host", "smtp.163.com");

		props.setProperty("mail.smtp.auth", "true");// 指定验证为true

		props.put("mail.smtp.port", "465");

        props.setProperty("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory");

        props.setProperty("mail.smtp.socketFactory.fallback", "false");

        props.setProperty("mail.smtp.socketFactory.port", "465");



		// 创建验证器

		Authenticator auth = new Authenticator() {

			public PasswordAuthentication getPasswordAuthentication() {

				return new PasswordAuthentication("test@163.com", "test");

			}

		};



		Session session = Session.getInstance(props, auth);



		// 2.创建一个Message，它相当于是邮件内容

		Message message = new MimeMessage(session);



		message.setFrom(new InternetAddress("test@163.com")); // 设置发送者



		message.setRecipient(RecipientType.TO, new InternetAddress(email)); // 设置发送方式与接收者

       

/*		String random

		String passwd = CustomeEncryptionUtil.bcryptPwd(pwd)*/

		String content ="注册成功";

		message.setSubject(content);



		message.setContent(emailMsg, "text/html;charset=utf-8");



		// 3.创建 Transport用于将邮件发送



		Transport.send(message);

		

	}

	

	public static void main(String[] args) {

		try {

			MailUtils.sendMail("dev@163.com", "你好，欢迎来到我的博客，在这里你将会获得前所未有的幸福");

		} catch (MessagingException e) {

			// TODO Auto-generated catch block

			e.printStackTrace();

			System.out.println("失败");

		}

	}

	

	

}







```



关键核心在于这:

```

		props.put("mail.smtp.port", "465");

        props.setProperty("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory");

        props.setProperty("mail.smtp.socketFactory.fallback", "false");

        props.setProperty("mail.smtp.socketFactory.port", "465");



```



我使用mail包依赖如下:

```

		<!-- 发邮件 -->

		<dependency>

			<groupId>com.sun.mail</groupId>

			<artifactId>javax.mail</artifactId>

			<version>1.5.2</version>

			<scope>provided</scope>

		</dependency>



```



另外说一下，如果你想确认你服务器上，端口是否可用，可用通过该命令(这样一来省的自己部署到服务器来测试，节约时间，提高效率):

```

telnet smtp.163.com 465



```



如果服务器返回是这样的结果，如下(一般是表示可用的):

```

Trying 220.181.12.11...

Connected to smtp.163.com.

Escape character is '^]'.

Connection closed by foreign host.





```

如果是这样会的结果，通常表示不可用(通常会一直卡在Trying，然后服务器可能会再次尝试Trying，不过还是没用):

```

Trying 220.181.12.16...



```